<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Project 1 — Images of the Russian Empire (Prokudin-Gorskii)</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    :root{ --bg:#0b0c10;--panel:#11131a;--text:#eaeef5;--muted:#9aa4b2;--accent:#7aa2ff;--border:#1d2230;--radius:16px;--gap:20px;--shadow:0 10px 30px rgba(0,0,0,.25) }
    @media (prefers-color-scheme: light){:root{--bg:#f6f8fb;--panel:#fff;--text:#0c1222;--muted:#4b5563;--border:#e5e7eb;--accent:#4169e1}}
    *{box-sizing:border-box}
    html,body{margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;line-height:1.6}
    a{color:var(--accent);text-decoration:none}
    a:hover{text-decoration:underline}
    .container{max-width:1280px;margin:0 auto;padding:32px 20px 80px}
    header.hero{background:linear-gradient(180deg,rgba(122,162,255,.08),rgba(122,162,255,0));padding:40px 0 10px}
    .title{font-size:clamp(26px,3.4vw,44px);font-weight:800;letter-spacing:-.02em;margin:0 0 8px}
    .subtitle{color:var(--muted);margin:0 0 24px}
    .meta{display:flex;gap:12px;flex-wrap:wrap;color:var(--muted);font-size:14px}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow)}
    .section{margin-top:36px}
    .section h2{font-size:clamp(22px,2.6vw,28px);margin:0 0 12px;letter-spacing:-.01em}
    .prose{padding:16px 18px}
    .prose p{margin:8px 0}
    figure{margin:0}
    figcaption{color:var(--muted);font-size:14px;margin-top:10px}
    .grid{display:grid;gap:var(--gap)}
    .grid.two{grid-template-columns:1fr}
    @media(min-width:880px){.grid.two{grid-template-columns:1fr 1fr}}
    .card{padding:14px}
    .media{position:relative;overflow:hidden;border-radius:calc(var(--radius) - 6px);border:1px solid var(--border);background:#000}
    img{display:block;width:100%;height:auto}
    .gallery{display:grid;grid-template-columns:repeat(auto-fill,minmax(340px,1fr));gap:calc(var(--gap) + 6px)}
    .thumb{cursor:pointer}
    .thumb:hover{outline:2px solid color-mix(in oklab, var(--accent) 50%, transparent)}
    .cap{display:flex;justify-content:space-between;gap:10px;align-items:center}
    .cap small{color:var(--muted)}
    .lightbox{position:fixed;inset:0;background:rgba(0,0,0,.85);display:none;align-items:center;justify-content:center;padding:20px;z-index:50}
    .lightbox.open{display:flex}
    .lightbox img{max-width:95vw;max-height:90vh}
    .lightbox .close{position:absolute;top:14px;right:18px;background:#0009;border:1px solid #fff3;color:#fff;padding:6px 10px;border-radius:10px;cursor:pointer}
    .kbd{font:600 12px/1.2 ui-monospace,SFMono-Regular,Menlo,monospace;background:#0009;color:#fff;padding:4px 8px;border-radius:6px;border:1px solid #ffffff33}
    table{width:100%;border-collapse:collapse}
    th,td{padding:10px;border-bottom:1px solid var(--border);text-align:left}
    tbody tr:hover{background:rgba(255,255,255,.025)}
    footer{margin-top:56px;color:var(--muted);font-size:13px;text-align:center}
    .ai-ack{margin-top:8px;color:var(--muted)}
    @media print{.container{padding:0}.panel{box-shadow:none}a{text-decoration:none;color:inherit}.thumb{cursor:auto;border:none}}
  </style>
</head>
<body>
  <header class="hero">
    <div class="container">
      <h1 class="title">Images of the Russian Empire — Prokudin-Gorskii</h1>
      <p class="subtitle">Aligning B/G/R plates into modern RGB photographs using <strong>binarized high-pass features</strong> scored with NCC, with a second iteration that refines shifts coarse → fine.</p>
      <div class="meta">
        <span><strong>Student:</strong> Eduardo</span><span>•</span>
        <span><strong>Course:</strong> CS180 — Fall 2025</span><span>•</span>
        <span><strong>Date:</strong> September 2025</span>
      </div>
    </div>
  </header>

  <main class="container">
    <section class="section">
      <div class="panel prose">
        <h2>Overview</h2>
        <p>The goal is to take the digitized Prokudin-Gorskii glass-plate images and automatically produce a color image with as few artifacts as possible. Each plate contains three grayscale exposures captured through different color filters stacked vertically (top→bottom: <strong>B, G, R</strong>). I extract the three channels, align G and R to B under an (x, y) translation model, and compose an RGB image.</p>
        <p>Full-resolution plates are large, so I begin with smaller images or downsampled versions, then scale up via a <em>coarse-to-fine image pyramid</em>. For each image I report the displacement vectors used to align G→B and R→B.</p>
      </div>
    </section>

    <section class="section">
      <h2>Core Idea — Binarized High-Pass Features</h2>
      <div class="panel prose">
        <p>Binarization is the distinctive choice in my pipeline. Rather than comparing raw intensities across channels (which often differ in brightness/contrast), I compare <em>structure</em> by computing a high-pass map, taking absolute value, and thresholding to a binary mask. This emphasizes edges/texture that are present in all channels and works well with normalized cross-correlation (NCC) to reduce sensitivity to gain/offset changes.</p>
      </div>
      <div class="panel" style="padding:14px">
        <h3 style="margin:8px 6px 10px">Example: Raw → High-Pass → Binarized</h3>
        <!-- use unique IDs -->
        <div id="binFeatRed" class="gallery"></div>
        <div id="binFeatBlue" class="gallery" style="margin-top:20px"></div>
      </div>
    </section>

    <section class="section">
      <h2>Approach</h2>
      <div class="panel prose">
        <p><strong>Single-scale baseline.</strong> Split B/G/R strips and align G and R to B by exhaustively searching displacements within a window using NCC on high-pass binarized features. Apply the best shift to the original channel and compose RGB.</p>
        <p><strong>Coarse-to-fine pyramid.</strong> For large displacements, build an image pyramid, estimate at coarse scale, and refine toward full resolution. Cropping a small border before scoring helps avoid plate-edge bias.</p>
      </div>
    </section>

    <section class="section">
      <h2>Iteration 1 — Results (Baseline)</h2>
      <div class="panel prose">
        <p>Aligned outputs for the required set. Displacements <em>(dx, dy)</em> are reported for <strong>G→B</strong> and <strong>R→B</strong>. Click any thumbnail to view larger.</p>
      </div>
      <div class="panel" style="padding:14px">
        <div id="gallery" class="gallery"></div>
      </div>
      <div class="panel" style="margin-top:var(--gap);padding:14px">
        <h3 style="margin:8px 6px 10px">Displacement Offsets</h3>
        <div style="overflow:auto">
          <table id="offsetsTable">
            <thead>
              <tr><th>Image</th><th>G → B (dx, dy)</th><th>R → B (dx, dy)</th></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </section>

    <section class="section">
      <h2>Iteration 2 — Results (Coarse-to-Fine + Simple Crop)</h2>
      <div class="panel prose">
        <p>A coarse-to-fine alignment wrapper that accumulates shifts from coarse → fine (with a simple inner crop to suppress plate borders), reusing the same high-pass + threshold + NCC matching.</p>
      </div>
      <div class="panel" style="padding:14px">
        <div id="gallery2" class="gallery"></div>
      </div>
      <div class="panel" style="margin-top:var(--gap);padding:14px">
        <h3 style="margin:8px 6px 10px">Displacement Offsets (Iteration 2)</h3>
        <div style="overflow:auto">
          <table id="offsetsTable2">
            <thead>
              <tr><th>Image</th><th>G → B (dx, dy)</th><th>R → B (dx, dy)</th></tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </section>

    <section class="section">
      <h2>Additional Examples from the Collection</h2>
      <div class="panel" style="padding:14px">
        <div id="galleryExtra" class="gallery"></div>
      </div>
    </section>

    <section class="section">
      <h2>Discussion: Failures &amp; Fixes</h2>
      <div class="panel prose">
        <p><strong>Brightness mismatch (e.g., Emir).</strong> Cross-channel intensity differences can still confuse raw-pixel similarity, which is why high-pass binarized features with NCC help. Increasing the crop margin or using gradient magnitude can further improve robustness.</p>
        <p><strong>Border artifacts.</strong> Strong horizontal borders from plate edges can dominate similarity. Cropping a fixed margin (e.g., 5–10% per side) before scoring helps.</p>
        <p><strong>Large shifts.</strong> A pyramid with smaller windows per level efficiently recovers large motions.</p>
      </div>
    </section>

    <section class="section">
      <h2>Intermediate Features Across Levels (Iteration 2)</h2>
      <div class="panel" style="padding:14px">
        <div id="levelsDebug" class="gallery"></div>
      </div>
    </section>

    <footer>
      <p>© <span id="year"></span> Eduardo • Project 1: Images of the Russian Empire</p>
      <p class="ai-ack">AI acknowledgment: I used ChatGPT (GPT-5 Thinking) to help draft this HTML/CSS template and organize content. All experiments, code, images, offsets, and write-up are my own; I reviewed and verified technical details.</p>
    </footer>
  </main>

  <div class="lightbox" id="lightbox" aria-modal="true" role="dialog">
    <button class="close" id="lbClose" aria-label="Close (Esc)"><span class="kbd">Esc</span></button>
    <img id="lbImg" alt="Expanded view"/>
  </div>

  <script>
    document.getElementById('year').textContent = new Date().getFullYear();

    // ====== DATASET ======
    const BASE_ITER1 = 'media/iteration_1';
    const BASE_ITER2 = 'media/iteration_2';
    const BASE_FEAT  = 'media/binarization';
    const BASE_DEBUG = 'media/debug';

    const results = [
      { id:"church",          file:"church.png",          g:[0,24],   r:[-11,55] },
      { id:"icon",            file:"icon.png",            g:[16,40],  r:[22,88] },
      { id:"emir",            file:"emir.png",            g:[24,48],  r:[40,104] },
      { id:"italil",          file:"italil.png",          g:[20,40],  r:[35,77] },
      { id:"lastochikino",    file:"lastochikino.png",    g:[0,-7],   r:[-7,77] },
      { id:"siren",           file:"siren.png",           g:[-8,48],  r:[-24,96] },
      { id:"three_generations",file:"three_generations.png",g:[11,55], r:[7,112] },
      { id:"lugano",          file:"lugano.png",          g:[-16,40], r:[-28,91] },
      { id:"cathedral",       file:"cathedral.png",       g:[2,5],    r:[3,12] },
      { id:"monastery",       file:"monastery.png",       g:[1,-3],   r:[2,3] },
      { id:"tobolsk",         file:"tobolsk.png",         g:[2,3],    r:[3,7] },
      { id:"harvesters",      file:"harvesters.png",      g:[18,63],  r:[9,126] },
      { id:"melons",          file:"melons.png",          g:[10,80],  r:[11,176] },
      { id:"self_portrait",   file:"self_portrait.png",   g:[28,77],  r:[36,180] }
    ];

    const results2 = [
      { id:"church",          file:"church.png",          g:[1,22],   r:[-8,55] },
      { id:"icon",            file:"icon.png",            g:[21,37],  r:[22,88] },
      { id:"emir",            file:"emir.png",            g:[22,46],  r:[37,103] },
      { id:"italil",          file:"italil.png",          g:[22,35],  r:[33,77] },
      { id:"lastochikino",    file:"lastochikino.png",    g:[0,-1],   r:[-11,77] },
      { id:"siren",           file:"siren.png",           g:[-3,52],  r:[-22,99] },
      { id:"three_generations",file:"three_generations.png", g:[11,55], r:[11,110] },
      { id:"lugano",          file:"lugano.png",          g:[-20,44], r:[-32,95] },
      { id:"cathedral",       file:"cathedral.png",       g:[2,5],    r:[3,12] },
      { id:"monastery",       file:"monastery.png",       g:[-3,2],   r:[2,3] },
      { id:"tobolsk",         file:"tobolsk.png",         g:[3,3],    r:[3,7] },
      { id:"harvesters",      file:"harvesters.png",      g:[13,64],  r:[11,128] },
      { id:"melons",          file:"melons.png",          g:[11,79],  r:[11,176] },
      { id:"self_portrait",   file:"self_portrait.png",   g:[31,77],  r:[33,176] }
    ];

    const extra = [ /* optional extras */ ];

    // ====== RENDER GALLERY ======
    function makeCard(basePath, item){
      const wrap = document.createElement('figure');
      wrap.className = 'card';
      const media = document.createElement('div');
      media.className = 'media thumb';
      const img = document.createElement('img');
      img.loading = 'lazy';
      img.alt = `${item.id} aligned result`;
      img.src = `${basePath}/${item.file}`;
      media.appendChild(img);
      const cap = document.createElement('figcaption');
      cap.className = 'cap';
      cap.innerHTML = `<span><strong>${item.id}</strong></span><small>G→B: (${item.g[0]}, ${item.g[1]}) • R→B: (${item.r[0]}, ${item.r[1]})</small>`;
      wrap.appendChild(media);
      wrap.appendChild(cap);
      media.addEventListener('click', ()=> openLightbox(`${basePath}/${item.file}`));
      return wrap;
    }

    function renderGallery(list, elId, basePath){
      const el = document.getElementById(elId);
      el.innerHTML = '';
      list.forEach(item => el.appendChild(makeCard(basePath, item)));
    }

    renderGallery(results, 'gallery', BASE_ITER1);
    renderGallery(results2, 'gallery2', BASE_ITER2);
    renderGallery(extra, 'galleryExtra', BASE_ITER1);

    // ====== RENDER TABLE ======
    function renderTable(list, tableId){
      const tbody = document.querySelector(`#${tableId} tbody`);
      tbody.innerHTML = '';
      list.forEach(item => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${item.id}</td><td>(${item.g[0]}, ${item.g[1]})</td><td>(${item.r[0]}, ${item.r[1]})</td>`;
        tbody.appendChild(tr);
      });
    }
    renderTable(results, 'offsetsTable');
    renderTable(results2, 'offsetsTable2');

    // ====== Iteration 2 Debug Levels ======
    const debugLevels = [
      { level: 11, file: 'example_L11.png' },
      { level: 10, file: 'example_L10.png' },
      { level: 9,  file: 'example_L9.png' },
      { level: 8,  file: 'example_L8.png' },
      { level: 7,  file: 'example_L7.png' }
    ];

    function makeDebugCard(basePath, item){
      const wrap = document.createElement('figure');
      wrap.className = 'card';
      const media = document.createElement('div');
      media.className = 'media thumb';
      const img = document.createElement('img');
      img.loading = 'lazy';
      img.alt = `Binarized high-pass at level ${item.level}`;
      img.src = `${basePath}/${item.file}`;
      media.appendChild(img);
      const cap = document.createElement('figcaption');
      cap.className = 'cap';
      cap.innerHTML = `<span><strong>Level ${item.level}</strong></span><small>Binarized features</small>`;
      wrap.appendChild(media);
      wrap.appendChild(cap);
      media.addEventListener('click', ()=> openLightbox(`${basePath}/${item.file}`));
      return wrap;
    }

    function renderDebug(list, elId, basePath){
      const el = document.getElementById(elId);
      el.innerHTML = '';
      list.forEach(item => el.appendChild(makeDebugCard(basePath, item)));
    }
    renderDebug(debugLevels, 'levelsDebug', BASE_DEBUG);

    // ====== Binarization examples (two rows) ======
    const binFeat1 = [
      { label: 'Input (emir: red plate)',           file: 'emir_redplate.png' },
      { label: 'High-pass filtered',                file: 'emir_redplate_highpass.png' },
      { label: 'High-pass filtered (absolute)',     file: 'emir_redplate_highpass_absolute.png' },
      { label: 'Binarized',                         file: 'emir_redplate_binarized.png' }
    ];

    const binFeat2 = [
      { label: 'Input (emir: blue plate)',          file: 'emir_blueplate.png' },
      { label: 'High-pass filtered',                file: 'emir_blueplate_highpass.png' },
      { label: 'High-pass filtered (absolute)',     file: 'emir_blueplate_highpass_absolute.png' },
      { label: 'Binarized',                         file: 'emir_blueplate_binarized.png' }
    ];

    function makeFeatCard(basePath, item){
      const wrap = document.createElement('figure');
      wrap.className = 'card';
      const media = document.createElement('div');
      media.className = 'media thumb';
      const img = document.createElement('img');
      img.loading = 'lazy';
      img.alt = item.label;
      img.src = `${basePath}/${item.file}`;
      media.appendChild(img);
      const cap = document.createElement('figcaption');
      cap.className = 'cap';
      cap.innerHTML = `<span><strong>${item.label}</strong></span>`;
      wrap.appendChild(media);
      wrap.appendChild(cap);
      media.addEventListener('click', ()=> openLightbox(`${basePath}/${item.file}`));
      return wrap;
    }

    function renderFeat(list, elId, basePath){
      const el = document.getElementById(elId);
      el.innerHTML = '';
      list.forEach(item => el.appendChild(makeFeatCard(basePath, item)));
    }

    renderFeat(binFeat1, 'binFeatRed', BASE_FEAT);
    renderFeat(binFeat2, 'binFeatBlue', BASE_FEAT);

    // ====== LIGHTBOX ======
    const lb = document.getElementById('lightbox');
    const lbImg = document.getElementById('lbImg');
    const lbClose = document.getElementById('lbClose');
    function openLightbox(src){ lbImg.src = src; lb.classList.add('open'); }
    function closeLightbox(){ lb.classList.remove('open'); lbImg.src = ''; }
    lb.addEventListener('click', (e)=>{ if(e.target===lb) closeLightbox(); });
    lbClose.addEventListener('click', closeLightbox);
    window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeLightbox(); });
  </script>
</body>
</html>
