<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CS180/280A Project 3B – Feature Matching for Autostitching: https://eduardo1100.github.io/CS180/3B/index.html</title>
  <meta name="description" content="Project 3B webpage: Harris corners, descriptors, matching, RANSAC mosaics, and bells & whistles." />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0b0e12;
      --ink: #e9edf2;
      --ink-dim: #b8c2cf;
      --card: #121821;
      --accent: #6aa1ff;
      --muted: #2a3340;
    }
    html, body { margin: 0; padding: 0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; background: var(--bg); color: var(--ink); }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    .container { max-width: 1100px; margin: 0 auto; padding: 2rem 1.25rem 4rem; }
    header { padding: 2.5rem 0 1.25rem; }
    .title { font-size: clamp(1.8rem, 2.4vw, 2.6rem); font-weight: 800; letter-spacing: 0.2px; margin: 0 0 0.25rem; }
    .subtitle { margin: 0.25rem 0 0; color: var(--ink-dim); }
    nav { position: sticky; top: 0; background: linear-gradient(180deg, rgba(11,14,18,0.95), rgba(11,14,18,0.7)); backdrop-filter: blur(8px); border-bottom: 1px solid var(--muted); z-index: 20; }
    nav .nav-inner { max-width: 1100px; margin: 0 auto; padding: 0.5rem 1.25rem; display: flex; gap: 1rem; flex-wrap: wrap; }
    nav a { font-size: 0.95rem; padding: 0.4rem 0.6rem; border-radius: 0.5rem; }
    nav a:hover { background: var(--muted); text-decoration: none; }

    section { padding: 2.25rem 0; border-bottom: 1px solid var(--muted); }
    h2 { font-size: clamp(1.4rem, 2vw, 1.8rem); margin: 0 0 0.75rem; }
    h3 { font-size: 1.05rem; margin: 1.25rem 0 0.25rem; color: var(--ink-dim); font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; }
    p { line-height: 1.7; color: var(--ink-dim); }
    .callout { background: #0f141c; border: 1px solid var(--muted); border-radius: 0.9rem; padding: 1rem 1rem; }

    .grid { display: grid; gap: 0.9rem; }
    .grid.cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    .grid.cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
    .grid.cols-4 { grid-template-columns: repeat(4, minmax(0, 1fr)); }
    @media (max-width: 880px) { .grid.cols-4 { grid-template-columns: repeat(2, 1fr); } }
    @media (max-width: 680px) { .grid.cols-3, .grid.cols-2 { grid-template-columns: 1fr; } }

    figure { margin: 0; background: var(--card); border: 1px solid var(--muted); border-radius: 1rem; overflow: hidden; }
    figure img { display: block; width: 100%; height: auto; }
    figcaption { padding: 0.75rem 0.9rem; font-size: 0.95rem; color: var(--ink-dim); border-top: 1px solid var(--muted); }

    .code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background: #0f141c; border: 1px solid var(--muted); border-radius: 0.6rem; padding: 0.75rem 0.9rem; color: var(--ink); overflow-x: auto; }

    .footer { padding-top: 2rem; color: var(--ink-dim); font-size: 0.95rem; }
    .tag { display: inline-block; background: #0f141c; border: 1px solid var(--muted); color: var(--ink-dim); padding: 0.15rem 0.5rem; border-radius: 0.5rem; font-size: 0.85rem; margin-right: 0.35rem; }
  </style>
</head>
<body>
  <nav>
    <div class="nav-inner">
      <a href="#overview">Overview</a>
      <a href="#b1">B.1 Harris Corners</a>
      <a href="#b2">B.2 Descriptors</a>
      <a href="#b3">B.3 Matching</a>
      <a href="#b4">B.4 RANSAC & Mosaics</a>
      <a href="#b5">B.5 Bells & Whistles</a>
      <a href="#results">Results Gallery</a>
      <a href="#implementation">Implementation Notes</a>
      <a href="#references">References</a>
    </div>
  </nav>

  <div class="container">
    <header>
      <h1 class="title">Project 3B – Feature Matching for Autostitching</h1>
      <p class="subtitle">CS180/280A – Intro to Computer Vision & Computational Photography</p>
      <p class="subtitle">Eduardo Cortes · Fall 2025</p>
    </header>

    <section id="overview">
      <h2>Overview</h2>
      <p>
        This project implements an end-to-end pipeline for <strong>automatic panorama stitching</strong>, including
        Harris corner detection, adaptive non-maximal suppression (ANMS), patch-based descriptors, feature matching with
        a nearest-neighbor ratio test, and robust homography estimation using 4-point RANSAC. The final step warps and blends images
        into mosaics and compares manual vs. automatic stitching.
      </p>
    </section>

    <section id="b1">
      <h2>B.1 – Harris Corner Detection</h2>
      <p>
        We detect corners with a Harris interest point operator and optionally refine the set with <em>Adaptive Non-Maximal Suppression</em> (ANMS).
      </p>
      <div class="grid cols-4">
        <figure>
          <img src="images/set1_harris_A.jpg" alt="Set 1 – Image A Harris corners" />
          <figcaption>Set 1 · Image A · Harris corners.</figcaption>
        </figure>
        <figure>
          <img src="images/set1_harris_B.jpg" alt="Set 1 – Image B Harris corners" />
          <figcaption>Set 1 · Image B · Harris corners.</figcaption>
        </figure>
        <figure>
          <img src="images/set1_anms_A.jpg" alt="Set 1 – Image A ANMS corners" />
          <figcaption>Set 1 · Image A · ANMS-selected corners.</figcaption>
        </figure>
        <figure>
          <img src="images/set1_anms_B.jpg" alt="Set 1 – Image B ANMS corners" />
          <figcaption>Set 1 · Image B · ANMS-selected corners.</figcaption>
        </figure>
      </div>

      <h3>Code (Harris + ANMS)</h3>
      <pre class="code">left_response  = harris_corner_response(left_gray)
right_response = harris_corner_response(right_gray)
left_x_all,  left_y_all,  left_scores_all  = nms_local_maxima(left_response,  harris_threshold_relative)
right_x_all, right_y_all, right_scores_all = nms_local_maxima(right_response, harris_threshold_relative)
left_x,  left_y,  _ = adaptive_nms(left_x_all,  left_y_all,  left_scores_all,  max_keypoints_after_anms)
right_x, right_y, _ = adaptive_nms(right_x_all, right_y_all, right_scores_all, max_keypoints_after_anms)</pre>
      <p class="callout">
        Harris response → local NMS → ANMS keeps strong, well-spaced corners.
      </p>
    </section>

    <section id="b2">
      <h2>B.2 – Feature Descriptor Extraction</h2>
      <p>
        Around each selected corner, we sample a <strong>40×40</strong> window (blurred / downsampled) to produce a normalized <strong>8×8</strong> grayscale descriptor (bias–gain normalized).
        Below are the <em>Set 1</em> overlays (40×40 boxes with center points at inlier corners) and the corresponding 8×8 descriptor montages.
      </p>

      <div class="grid cols-4">
        <figure>
          <img src="images/set1_desc_A_patch_boxes.jpg" alt="Set 1 – Image A patch boxes + centers" />
          <figcaption>Set 1 · Image A · 40×40 patch boxes (inlier corners) + center points.</figcaption>
        </figure>
        <figure>
          <img src="images/set1_desc_B_patch_boxes.jpg" alt="Set 1 – Image B patch boxes + centers" />
          <figcaption>Set 1 · Image B · 40×40 patch boxes (inlier corners) + center points.</figcaption>
        </figure>
        <figure>
          <img src="images/set1_desc_A_montage.png" alt="Set 1 – Image A montage of 8×8 descriptors" />
          <figcaption>Set 1 · Image A · Montage of 8×8 normalized descriptor patches.</figcaption>
        </figure>
        <figure>
          <img src="images/set1_desc_B_montage.png" alt="Set 1 – Image B montage of 8×8 descriptors" />
          <figcaption>Set 1 · Image B · Montage of 8×8 normalized descriptor patches.</figcaption>
        </figure>
      </div>

      <h3>Code (Patch → 8×8 → z-score)</h3>
      <pre class="code">patch   = extract_square_patch(gray, x_val, y_val, size=40)
patch8  = resize_patch_to_8x8(patch)             # 40→8
descriptor = normalize_descriptor_vector(patch8)  # z-score</pre>
      <p class="callout">
        Each corner yields a 40×40 patch, resized to 8×8 and z-scored to reduce illumination effects.
      </p>
    </section>

    <section id="b3">
      <h2>B.3 – Feature Matching</h2>
      <p>
        We compute nearest neighbors in descriptor space and apply Lowe’s <em>ratio test</em> to keep reliable correspondences.
      </p>
      <div class="grid cols-2">
        <figure>
          <img src="images/set1_matches_filtered.jpg" alt="Set 1 – Filtered matches after Lowe ratio test" />
          <figcaption>Set 1 · Filtered matches (post ratio test).</figcaption>
        </figure>
        <figure>
          <img src="images/set2_matches_filtered.jpg" alt="Set 2 – Filtered matches after Lowe ratio test" />
          <figcaption>Set 2 · Filtered matches (post ratio test).</figcaption>
        </figure>
      </div>

      <h3>Code (Lowe ratio)</h3>
      <pre class="code">def match_with_lowe_ratio(descriptors_left: np.ndarray, descriptors_right: np.ndarray, ratio_threshold: float = lowe_ratio_threshold):
    matches = []
    if len(descriptors_left) == 0 or len(descriptors_right) == 0:
        return matches
    distances = np.sum((descriptors_left[:, None, :] - descriptors_right[None, :, :]) ** 2, axis=2)
    for idx_left in range(descriptors_left.shape[0]):
        row = distances[idx_left]
        order = np.argsort(row)
        idx_right_best = int(order[0])
        idx_right_next = int(order[1]) if len(order) > 1 else int(order[0])
        best_dist = float(row[idx_right_best])
        next_dist = float(row[idx_right_next])
        if next_dist == 0:
            continue
        if best_dist / next_dist &lt; ratio_threshold:
            matches.append((idx_left, idx_right_best, best_dist, next_dist))
    return matches</pre>
      <p class="callout">
        Accept a match only if best/second-best distance ratio is below <code>lowe_ratio_threshold</code>.
      </p>
    </section>

    <section id="b4">
      <h2>B.4 – RANSAC for Robust Homography & Mosaics</h2>
      <p>
        Using 4-point RANSAC, we estimate a homography from inlier matches, warp one image into the other’s frame, and blend to form a mosaic.
      </p>
      <div class="grid cols-2">
        <figure>
          <img src="images/set1_ransac_inliers.jpg" alt="Set 1 – RANSAC inliers visualization" />
          <figcaption>Set 1 · RANSAC inliers (green) vs outliers (red).</figcaption>
        </figure>
        <figure>
          <img src="images/set1_mosaic_auto.jpg" alt="Set 1 – Automatically stitched mosaic" />
          <figcaption>Set 1 · Automatically stitched mosaic.</figcaption>
        </figure>
      </div>

      <h3>Code (RANSAC + warp)</h3>
      <pre class="code">def ransac_fit_homography(src_xy: np.ndarray, dst_xy: np.ndarray, max_iters: int = ransac_max_iterations, eps: float = ransac_inlier_epsilon):
    best_inlier_mask = None
    best_homography = None
    count = src_xy.shape[0]
    if count &lt; 4:
        return None, np.array([], dtype=bool)
    for _ in range(max_iters):
        sample_idx = np.random.choice(count, 4, replace=False)
        candidate = dlt_homography(src_xy[sample_idx], dst_xy[sample_idx])
        predicted = apply_homography_points(src_xy, candidate)
        error = np.sqrt(np.sum((predicted - dst_xy) ** 2, axis=1))
        inliers = error &lt; eps
        if best_inlier_mask is None or np.count_nonzero(inliers) &gt; np.count_nonzero(best_inlier_mask):
            best_inlier_mask = inliers
            best_homography = candidate
    if best_inlier_mask is not None and np.count_nonzero(best_inlier_mask) &gt;= 4:
        best_homography = dlt_homography(src_xy[best_inlier_mask], dst_xy[best_inlier_mask])
    else:
        best_homography = None
        best_inlier_mask = np.zeros(count, dtype=bool)
    return best_homography, best_inlier_mask</pre>
      <p class="callout">
        Sample 4 correspondences → fit H (DLT) → score inliers by reprojection error → keep best set → refit on inliers → inverse-warp + feather-blend.
      </p>
    </section>

    <section id="results">
      <h2>Results Gallery</h2>
      <p>A compact gallery of favorites from the project. Click to view full resolution.</p>
      <div class="grid cols-3">
        <figure>
          <a href="images/set1_mosaic_auto.jpg" target="_blank" rel="noopener"><img src="images/set1_mosaic_auto.jpg" alt="Gallery mosaic – Set 1" /></a>
          <figcaption>Gallery mosaic · Set 1.</figcaption>
        </figure>
        <figure>
          <a href="images/set2_mosaic_auto.jpg" target="_blank" rel="noopener"><img src="images/set2_mosaic_auto.jpg" alt="Gallery mosaic – Set 2" /></a>
          <figcaption>Gallery mosaic · Set 2.</figcaption>
        </figure>
        <figure>
          <a href="images/set3_mosaic_auto.jpg" target="_blank" rel="noopener"><img src="images/set3_mosaic_auto.jpg" alt="Gallery mosaic – Set 3" /></a>
          <figcaption>Gallery mosaic · Set 3.</figcaption>
        </figure>
      </div>
    </section>

    <section id="implementation">
      <h2>Implementation Notes</h2>
      <p>
        Briefly summarize key implementation choices (e.g., Harris parameters, ANMS radius logic, descriptor normalization, ratio threshold, RANSAC iterations and inlier metric), and include any ablations or pitfalls.
      </p>
      <pre class="code">
max_keypoints_after_anms = 750
harris_k_coeff = 0.04
harris_window_size = 3
harris_threshold_relative = 0.01
lowe_ratio_threshold = 0.7
ransac_max_iterations = 2000
ransac_inlier_epsilon = 3.0</pre>
    </section>

    <section id="references">
      <h2>References</h2>
      <ul>
        <li>Brown, Szeliski, Winder. <em>Multi-Image Matching using Multi-Scale Oriented Patches (MOPS)</em>.</li>
        <li>Harris & Stephens. <em>A Combined Corner and Edge Detector</em>.</li>
        <li>Lowe. <em>Distinctive Image Features from Scale-Invariant Keypoints</em> – ratio test idea.</li>
      </ul>
      <p class="footer">Last updated: <span id="last-updated">—</span></p>
    </section>

    <footer class="footer">
      <p>
        © 2025 Eduardo Cortes. This page is part of CS180/280A coursework. Images are my own unless otherwise noted.
      </p>
      <p class="ai-ack">AI acknowledgment: I used ChatGPT (GPT-5 Thinking) to help draft this HTML/CSS template and organize content. All experiments, code, images, offsets, and write-up are my own; I reviewed and verified technical details.</p>
    </footer>
  </div>

  <script>
    // Set last updated time programmatically
    const span = document.getElementById('last-updated');
    if (span) {
      const d = new Date();
      const fmt = new Intl.DateTimeFormat([], { year: 'numeric', month: 'short', day: '2-digit' }).format(d);
      span.textContent = fmt;
    }
  </script>
</body>
</html>
